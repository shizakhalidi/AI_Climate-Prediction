from __future__ import division


import random
import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
from matplotlib import patches as patches

#Initializing the setup
def initialize(file):
  
  #load dataset
  dataset = pd.read_csv(file, sep=",", header=None)
  
  #raw data of 3D vectors
  #vectors represent the three green house gases [methane, CO2, NO2]
  raw_data = np.zeros((dataset.shape[0],3))
  
  for i in range(1, dataset.shape[0]):
      raw_data[i][0] = dataset[2][i]
      raw_data[i][1] = dataset[3][i]
      raw_data[i][2] = dataset[4][i]
  
  raw_data = np.delete(raw_data, 0, 0)
  return raw_data


def preprocess(data):

  normalized_data = data  #copying so that original data is not lost (maybe unnecessary, did it rn cuz not sure)

  sums = normalized_data.sum(axis=1)
  normalized_data = normalized_data / sums[:, np.newaxis]
  
  return normalized_data

dimensions = np.array([20,20]) #20 x 20 matrix
iterations = 1000
learning_rate = 0.01

raw_data = initialize('greenhouse_gases_data.csv')
raw_data=raw_data.transpose()

m = raw_data.shape[0]
print(m)
n = raw_data.shape[1]
print(n)
weight_matrix =  np.random.random((dimensions[0], dimensions[1], m)) #randomized weight vector for SOM
radius = max(dimensions[0], dimensions[1])/2  #neighborhood radius
decay = iterations/np.log(radius)

normalized = preprocess(raw_data)


def find_bmu(t, net, m):
    """
        Find the best matching unit for a given vector, t, in the SOM
        Returns: a (bmu, bmu_idx) tuple where bmu is the high-dimensional BMU
                 and bmu_idx is the index of this vector in the SOM
    """
    bmu_idx = np.array([0, 0])
    # set the initial minimum distance to a huge number
    min_dist = np.iinfo(np.int).max    
    # calculate the high-dimensional distance between each neuron and the input
    for x in range(net.shape[0]):
        for y in range(net.shape[1]):
            w = net[x, y, :].reshape(m, 1)
            # don't bother with actual Euclidean distance, to avoid expensive sqrt operation
            sq_dist = np.sum((w - t) ** 2)
            if sq_dist < min_dist:
                min_dist = sq_dist
                bmu_idx = np.array([x, y])
    # get vector corresponding to bmu_idx
    bmu = net[bmu_idx[0], bmu_idx[1], :].reshape(m, 1)
    # return the (bmu, bmu_idx) tuple
    return (bmu, bmu_idx)

def decay_radius(initial_radius, i, time_constant):
    return initial_radius * np.exp(-i / time_constant)

def decay_learning_rate(initial_learning_rate, i, n_iterations):
    return initial_learning_rate * np.exp(-i / n_iterations)

def calculate_influence(distance, radius):
    return np.exp(-distance / (2* (radius**2)))

for i in range(iterations):
    #print('Iteration %d' % i)
    
    # select a training example at random
    t = normalized[:, np.random.randint(0, n)].reshape(np.array([m, 1]))
    
    # find its Best Matching Unit
    bmu, bmu_idx = find_bmu(t, weight_matrix, m)
    
    # decay the SOM parameters
    r = decay_radius(radius, i, decay)
    l = decay_learning_rate(learning_rate, i, iterations)
    
    # now we know the BMU, update its weight vector to move closer to input
    # and move its neighbours in 2-D space closer
    # by a factor proportional to their 2-D distance from the BMU
    for x in range(weight_matrix.shape[0]):
        for y in range(weight_matrix.shape[1]):
            w = weight_matrix[x, y, :].reshape(m, 1)
            # get the 2-D distance (again, not the actual Euclidean distance)
            w_dist = np.sum((np.array([x, y]) - bmu_idx) ** 2)
            # if the distance is within the current neighbourhood radius
            if w_dist <= r**2:
                # calculate the degree of influence (based on the 2-D distance)
                influence = calculate_influence(w_dist, r)
                # now update the neuron's weight using the formula:
                # new w = old w + (learning rate * influence * delta)
                # where delta = input vector (t) - old w
                new_w = w + (l * influence * (t - w))
                # commit the new weight
                weight_matrix[x, y, :] = new_w.reshape(1, 3)
print(weight_matrix)
fig = plt.figure()
# setup axes
ax = fig.add_subplot(111, aspect='equal')
ax.set_xlim((0, weight_matrix.shape[0]+1))
ax.set_ylim((0, weight_matrix.shape[1]+1))
ax.set_title('Self-Organising Map after %d iterations' % iterations)

# plot the rectangles
for x in range(1, weight_matrix.shape[0] + 1):
    for y in range(1, weight_matrix.shape[1] + 1):
        #print(net[x-1,y-1,:])
        ax.add_patch(patches.Rectangle((x-0.5, y-0.5), 0.5, 0.5,
                     facecolor=weight_matrix[x-1,y-1,:],
                     edgecolor='none'))
plt.show()

